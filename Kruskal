#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Disjoint Set Union (DSU) class
class DisjointSet {
    vector<int> parent, rank;

public:
    // Constructor
    DisjointSet(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    // Find function with path compression
    int findUPar(int u) {
        if (u == parent[u]) return u;
        return parent[u] = findUPar(parent[u]);
    }

    // Union by rank
    void unionBySize(int u, int v) {
        int rootU = findUPar(u);
        int rootV = findUPar(v);

        if (rootU != rootV) {
            if (rank[rootU] < rank[rootV]) {
                parent[rootU] = rootV;
            } else if (rank[rootU] > rank[rootV]) {
                parent[rootV] = rootU;
            } else {
                parent[rootV] = rootU;
                rank[rootU]++;
            }
        }
    }
};

// Kruskal's Algorithm
int kruskalMST(int V, vector<vector<pair<int, int>>> &adj) {
    vector<pair<int, pair<int, int>>> edges;

    // Convert adjacency list to edge list
    for (int i = 0; i < V; i++) {
        for (auto it : adj[i]) {
            int adjNode = it.first;
            int weight = it.second;

            // Avoid duplicate edges in undirected graph
            if (i < adjNode) {
                edges.push_back({weight, {i, adjNode}});
            }
        }
    }

    // Sort edges by weight
    sort(edges.begin(), edges.end());

    // Initialize DSU
    DisjointSet ds(V);
    int mstWt = 0;

    // Process edges
    for (auto it : edges) {
        int wt = it.first;
        int u = it.second.first;
        int v = it.second.second;

        // If u and v are in different components, include edge in MST
        if (ds.findUPar(u) != ds.findUPar(v)) {
            mstWt += wt;
            ds.unionBySize(u, v);
        }
    }

    return mstWt;
}

int main() {
    int V = 5; // Number of vertices

    // Adjacency list representation
    vector<vector<pair<int, int>>> adj(V);
    adj[0].push_back({1, 2});
    adj[0].push_back({3, 6});
    adj[1].push_back({0, 2});
    adj[1].push_back({2, 3});
    adj[1].push_back({3, 8});
    adj[1].push_back({4, 5});
    adj[2].push_back({1, 3});
    adj[2].push_back({4, 7});
    adj[3].push_back({0, 6});
    adj[3].push_back({1, 8});
    adj[4].push_back({1, 5});
    adj[4].push_back({2, 7});

    // Calculate MST weight
    int mstWeight = kruskalMST(V, adj);
    cout << "Total weight of the MST is: " << mstWeight << endl;

    return 0;
}
